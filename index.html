<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI é›™èªå£è­¯æ©Ÿ (æ‰“å­—ä¿®å¾©ç‰ˆ)</title>
    <script type="importmap">
      {
        "imports": {
          "@google/generative-ai": "https://esm.run/@google/generative-ai"
        }
      }
    </script>
    <style>
        :root {
            --bg-color: #000000;
            --card-bg: #1c1c1e;
            --btn-blue: #007aff;
            --btn-red: #ff3b30;
            --btn-purple: #af52de;
            --text-main: #ffffff;
            --text-sub: #8e8e93;
            --bubble-me: #007aff;
            --bubble-other: #2c2c2e;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            margin: 0; padding: 0;
            display: flex; flex-direction: column; height: 100vh;
            color: var(--text-main);
            overflow: hidden;
            touch-action: manipulation;
            -webkit-user-select: none; user-select: none;
        }

        /* --- é ‚éƒ¨å°èˆª --- */
        .navbar {
            height: 44px; display: flex; justify-content: space-between; align-items: center;
            padding: 0 16px; background: rgba(28, 28, 30, 0.8);
            backdrop-filter: blur(10px); border-bottom: 0.5px solid #333;
            z-index: 100;
        }

        .status-text { font-size: 14px; font-weight: 600; color: var(--text-sub); }
        .btn-gear { background: none; border: none; font-size: 20px; padding: 8px; cursor: pointer; opacity: 0.8; }

        /* --- è¢å¹•å°è©±å€ --- */
        .screen {
            flex: 1; padding: 20px 16px; overflow-y: auto; 
            display: flex; flex-direction: column; gap: 20px;
            -webkit-overflow-scrolling: touch;
        }

        .welcome-text {
            text-align: center; color: #555; margin-top: auto; padding-bottom: 20px;
            font-size: 13px; letter-spacing: 0.5px;
        }

        /* --- å°è©±æ°£æ³¡ --- */
        .msg {
            max-width: 85%; padding: 12px 16px; border-radius: 18px;
            font-size: 17px; line-height: 1.5; /* å¢åŠ è¡Œè·è®“æ—¥æ–‡æ›´å¥½è®€ */
            position: relative; word-wrap: break-word;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
            flex-shrink: 0;
            min-height: 24px;
        }
        .msg.clickable { cursor: pointer; }
        
        .msg-me { align-self: flex-end; background: var(--bubble-me); color: white; border-bottom-right-radius: 4px; }
        .msg-other { align-self: flex-start; background: var(--bubble-other); color: white; border-bottom-left-radius: 4px; }

        /* ç¿»è­¯æ–‡å­—å€ */
        .translation {
            display: block; margin-top: 8px; padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 19px; /* æ—¥æ–‡ç¿»è­¯å­—å¤§ä¸€é» */
            font-weight: 600; color: #ffcc00;
            min-height: 20px; white-space: pre-wrap;
        }
        .translation-source {
            display: block;
            margin-top: 8px;
            padding: 10px 12px;
            border-radius: 12px;
            background: #2f2f33;
            color: #d0d0d0;
            font-size: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        /* æ‰“å­—æ¸¸æ¨™ */
        .typing::after {
            content: 'â–‹'; display: inline-block; vertical-align: bottom;
            animation: blink 0.8s infinite; color: #ffcc00; font-size: 16px; margin-left: 2px;
        }
        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        /* --- åº•éƒ¨æ§åˆ¶å€ --- */
        .controls {
            background: var(--card-bg);
            border-top-left-radius: 24px; border-top-right-radius: 24px;
            padding: 20px 0 40px 0;
            box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; align-items: center;
            z-index: 200;
        }

        /* è† å›Šåˆ‡æ›å™¨ */
        .lang-switch-container {
            background: #2c2c2e; padding: 3px; border-radius: 30px;
            display: flex; margin-bottom: 25px;
        }

        .lang-option {
            padding: 8px 24px; border-radius: 25px; font-size: 14px; font-weight: 600;
            color: #8e8e93; cursor: pointer; transition: all 0.3s ease;
        }
        .lang-option.active { color: #fff; background: #636366; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        .lang-option[data-lang="ja"].active { background: var(--btn-red); }
        .lang-option[data-lang="en"].active { background: var(--btn-purple); }

        /* æ¨¡å¼åˆ‡æ› */
        .mode-switch {
            display: flex; gap: 8px; margin: 0 16px 16px;
        }
        .mode-option {
            flex: 1; text-align: center; padding: 10px 12px; border-radius: 14px;
            background: #2c2c2e; color: #8e8e93; font-weight: 600; cursor: pointer;
            transition: all 0.2s ease;
        }
        .mode-option.active { color: #fff; background: #3a3a3c; box-shadow: 0 4px 16px rgba(0,0,0,0.35); }

        /* æŒ‰éˆ•å®¹å™¨ */
        .btn-row { display: flex; justify-content: space-evenly; width: 100%; align-items: center; }

        /* åœ“å½¢æŒ‰éˆ• */
        .mic-btn {
            width: 90px; height: 90px; border-radius: 50%; background: #3a3a3c;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; font-size: 20px; font-weight: 700;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            transition: transform 0.1s, background 0.3s;
            position: relative; border: 3px solid #3a3a3c;
        }

        .mic-btn:active { transform: scale(0.95); }
        .mic-btn span.label { font-size: 12px; font-weight: 400; color: #aaa; margin-top: 2px; }

        /* éŒ„éŸ³ä¸­æ¨£å¼ */
        .mic-btn.recording { transform: scale(1.1); border-color: #fff; }
        .btn-tw.recording { background: var(--btn-blue); box-shadow: 0 0 30px rgba(0, 122, 255, 0.5); }
        .btn-other.jp-mode.recording { background: var(--btn-red); box-shadow: 0 0 30px rgba(255, 59, 48, 0.5); }
        .btn-other.en-mode.recording { background: var(--btn-purple); box-shadow: 0 0 30px rgba(175, 82, 222, 0.5); }

        /* Modal */
        .modal {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.6); backdrop-filter: blur(8px);
            z-index: 1000; display: none; justify-content: center; align-items: center;
        }
        .modal-card {
            background: #2c2c2e; padding: 24px; border-radius: 20px; width: 85%; max-width: 320px;
            text-align: center; border: 1px solid #444; box-shadow: 0 20px 40px rgba(0,0,0,0.6);
        }
        .modal-input {
            width: 100%; padding: 12px; margin: 15px 0; background: #1c1c1e;
            border: 1px solid #48484a; border-radius: 10px; color: #fff; font-size: 14px;
            box-sizing: border-box;
        }
        .modal-btn {
            width: 100%; padding: 12px; background: var(--btn-blue); border: none;
            border-radius: 10px; color: white; font-weight: bold; font-size: 16px; cursor: pointer;
        }

        /* éŸ³é‡æŒ‡ç¤ºå™¨ */
        .volume-meter {
            display: none;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            margin-bottom: 15px;
        }
        .volume-meter.active { display: flex; }
        .volume-meter-label { font-size: 11px; color: #8e8e93; }
        .volume-bars {
            display: flex;
            gap: 2px;
            align-items: flex-end;
            height: 20px;
        }
        .volume-bar {
            width: 4px;
            background: #3a3a3c;
            border-radius: 2px;
            transition: height 0.05s, background 0.1s;
        }
        .volume-bar.active { background: #32d74b; }
        .volume-bar.high { background: #ff9500; }
        .volume-bar.peak { background: #ff3b30; }
        .volume-level {
            font-size: 11px;
            color: #32d74b;
            min-width: 28px;
            text-align: right;
            font-weight: 600;
        }

        /* æ–‡å­—ç¿»è­¯é¢æ¿ */
        .text-panel {
            width: calc(100% - 32px);
            background: #1c1c1e;
            border: 1px solid #2f2f31;
            border-radius: 16px;
            padding: 14px;
            box-sizing: border-box;
            display: none;
            gap: 10px;
            flex-direction: column;
        }
        .text-panel.active { display: flex; }
        .text-input {
            width: 100%;
            min-height: 90px;
            background: #0f0f11;
            border: 1px solid #2f2f31;
            border-radius: 12px;
            padding: 10px;
            color: #fff;
            font-size: 15px;
            box-sizing: border-box;
        }
        .text-actions {
            display: flex;
            gap: 10px;
        }
        .text-btn {
            flex: 1;
            padding: 12px;
            background: var(--btn-blue);
            border: none;
            border-radius: 12px;
            color: #fff;
            font-weight: 700;
            font-size: 15px;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }
        .text-btn.secondary { background: #3a3a3c; color: #ddd; }
        .text-btn:active { transform: scale(0.97); }
        .text-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #8e8e93;
            font-size: 13px;
        }
        .text-select {
            background: #0f0f11;
            color: #fff;
            border: 1px solid #2f2f31;
            border-radius: 10px;
            padding: 8px 10px;
        }

        /* åœ–ç‰‡ç¿»è­¯é¢æ¿ */
        .image-panel {
            width: calc(100% - 32px);
            background: #1c1c1e;
            border: 1px solid #2f2f31;
            border-radius: 16px;
            padding: 14px;
            box-sizing: border-box;
            display: none;
            gap: 10px;
            flex-direction: column;
        }
        .image-panel.active { display: flex; }
        .image-actions { display: flex; gap: 10px; }
        .image-btn {
            flex: 1;
            padding: 12px;
            background: #3a3a3c;
            border: 1px solid #4a4a4c;
            border-radius: 12px;
            color: #fff;
            font-weight: 700;
            font-size: 15px;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
        }
        .image-btn.primary { background: var(--btn-blue); border-color: var(--btn-blue); }
        .image-btn:active { transform: scale(0.97); }
        .image-hint { color: #8e8e93; font-size: 13px; }
        .img-preview {
            width: 120px;
            max-height: 140px;
            border-radius: 10px;
            object-fit: cover;
            display: block;
            margin-bottom: 8px;
        }
        .hidden { display: none !important; }

    </style>
</head>
<body>

    <div class="navbar">
        <div style="width:30px;"></div>
        <div class="status-text" id="statusText">Ready</div>
        <button class="btn-gear" onclick="openModal()">âš™ï¸</button>
    </div>

    <div class="screen" id="screen">
        <div class="welcome-text">
            é¸æ“‡èªè¨€ âœ é»æ“ŠæŒ‰éˆ•èªªè©±
        </div>
    </div>

    <div class="controls">
        <div class="mode-switch">
            <div class="mode-option active" data-mode="voice" onclick="switchMode('voice')">ğŸ™ èªéŸ³æ¨¡å¼</div>
            <div class="mode-option" data-mode="text" onclick="switchMode('text')">âŒ¨ï¸ æ–‡å­—æ¨¡å¼</div>
            <div class="mode-option" data-mode="image" onclick="switchMode('image')">ğŸ–¼ï¸ åœ–ç‰‡æ¨¡å¼</div>
        </div>
        <!-- éŸ³é‡æŒ‡ç¤ºå™¨ -->
        <div class="volume-meter" id="volumeMeter">
            <span class="volume-meter-label">ğŸ¤</span>
            <div class="volume-bars" id="volumeBars">
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
                <div class="volume-bar" style="height: 4px;"></div>
            </div>
            <span class="volume-level" id="volumeLevel">0%</span>
        </div>

        <div class="lang-switch-container">
            <div class="lang-option active" data-lang="ja" onclick="switchLang('ja')">ğŸ‡¯ğŸ‡µ æ—¥æ–‡</div>
            <div class="lang-option" data-lang="en" onclick="switchLang('en')">ğŸ‡ºğŸ‡¸ è‹±æ–‡</div>
        </div>

        <div class="text-panel" id="textPanel">
            <div class="text-meta">
                <span>è¼¸å…¥æ–‡å­—ç¿»è­¯</span>
                <select id="textTarget" class="text-select">
                    <option value="zh">ç¹ä¸­</option>
                    <option value="ja">æ—¥æ–‡</option>
                    <option value="en">è‹±æ–‡</option>
                </select>
            </div>
            <textarea id="textInput" class="text-input" placeholder="åœ¨æ­¤è¼¸å…¥è¦ç¿»è­¯çš„å…§å®¹..."></textarea>
            <div class="text-actions">
                <button class="text-btn" onclick="handleTextTranslate()">ç¿»è­¯</button>
                <button class="text-btn secondary" onclick="clearTextInput()">æ¸…é™¤</button>
            </div>
        </div>

        <div class="image-panel" id="imagePanel">
            <div class="text-meta">
                <span>åœ–ç‰‡ç¿»è­¯</span>
                <select id="imageTarget" class="text-select">
                    <option value="zh">ç¹ä¸­</option>
                    <option value="ja">æ—¥æ–‡</option>
                    <option value="en">è‹±æ–‡</option>
                </select>
            </div>
            <div class="image-actions">
                <button class="image-btn primary" onclick="triggerImageUpload()">ä¸Šå‚³åœ–ç‰‡</button>
                <button class="image-btn" onclick="triggerImageCapture()">æ‹ç…§ / ç›¸æ©Ÿ</button>
            </div>
            <div class="image-hint">æ”¯æ´ä¸Šå‚³æˆ–ç›¸æ©Ÿæ‹æ”ï¼Œç¿»è­¯åœ–ç‰‡ä¸­çš„æ–‡å­—ä¸¦é¡¯ç¤ºæ–¼å°è©±å€ã€‚</div>
            <input id="imageFileInput" type="file" accept="image/*" class="hidden" />
            <input id="imageCaptureInput" type="file" accept="image/*" capture="environment" class="hidden" />
        </div>

        <div class="btn-row">
            <div id="btnOther" class="mic-btn btn-other jp-mode">
                <span id="btnOtherText">JP</span>
                <span class="label">å°æ–¹</span>
            </div>
            <div id="btnTW" class="mic-btn btn-tw">
                <span>TW</span>
                <span class="label">æˆ‘</span>
            </div>
        </div>
    </div>

    <div id="keyModal" class="modal">
        <div class="modal-card">
            <h3 style="color:#fff; margin:0 0 10px 0; font-size:18px;">è¨­å®š API Key</h3>
            <input type="password" id="apiKey" class="modal-input" placeholder="è²¼ä¸Š Key...">
            <button class="modal-btn" onclick="saveKey()">å„²å­˜</button>
        </div>
    </div>

    <script type="module">
        import { GoogleGenerativeAI } from "@google/generative-ai";

        let genAI, model;
        let recognition;
        let isRecording = false;
        let btnLock = false;
        let currentBtn = null;
        let audioCtx = null; 
        
        let targetLangMode = 'ja';
        let currentMode = 'voice';

        // --- éŸ³é‡ç›£æ¸¬ ---
        let volumeAudioCtx = null;
        let volumeAnalyser = null;
        let volumeMicStream = null;
        let volumeAnimationId = null;

        async function startVolumeMeter() {
            try {
                volumeMicStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                volumeAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                volumeAnalyser = volumeAudioCtx.createAnalyser();
                volumeAnalyser.fftSize = 256;
                
                const source = volumeAudioCtx.createMediaStreamSource(volumeMicStream);
                source.connect(volumeAnalyser);
                
                document.getElementById('volumeMeter').classList.add('active');
                updateVolumeMeter();
            } catch(e) {
                console.error('Volume meter error:', e);
            }
        }

        function updateVolumeMeter() {
            if (!volumeAnalyser) return;
            
            const dataArray = new Uint8Array(volumeAnalyser.frequencyBinCount);
            volumeAnalyser.getByteFrequencyData(dataArray);
            
            // è¨ˆç®—å¹³å‡éŸ³é‡
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;
            const volumePercent = Math.min(100, Math.round((average / 128) * 100));
            
            // æ›´æ–°éŸ³é‡æ¢
            const bars = document.querySelectorAll('.volume-bar');
            const activeCount = Math.ceil((volumePercent / 100) * bars.length);
            
            bars.forEach((bar, i) => {
                const height = 4 + (i * 1.6); // æ¼¸é«˜
                bar.style.height = height + 'px';
                bar.classList.remove('active', 'high', 'peak');
                
                if (i < activeCount) {
                    if (i >= 8) bar.classList.add('peak');
                    else if (i >= 6) bar.classList.add('high');
                    else bar.classList.add('active');
                }
            });
            
            // æ›´æ–°ç™¾åˆ†æ¯”
            const levelEl = document.getElementById('volumeLevel');
            levelEl.textContent = volumePercent + '%';
            if (volumePercent >= 80) levelEl.style.color = '#ff3b30';
            else if (volumePercent >= 50) levelEl.style.color = '#ff9500';
            else if (volumePercent >= 20) levelEl.style.color = '#32d74b';
            else levelEl.style.color = '#8e8e93';
            
            volumeAnimationId = requestAnimationFrame(updateVolumeMeter);
        }

        function stopVolumeMeter() {
            if (volumeAnimationId) {
                cancelAnimationFrame(volumeAnimationId);
                volumeAnimationId = null;
            }
            if (volumeMicStream) {
                volumeMicStream.getTracks().forEach(track => track.stop());
                volumeMicStream = null;
            }
            if (volumeAudioCtx) {
                volumeAudioCtx.close();
                volumeAudioCtx = null;
                volumeAnalyser = null;
            }
            document.getElementById('volumeMeter').classList.remove('active');
            
            // é‡ç½®éŸ³é‡æ¢
            const bars = document.querySelectorAll('.volume-bar');
            bars.forEach(bar => {
                bar.classList.remove('active', 'high', 'peak');
                bar.style.height = '4px';
            });
            document.getElementById('volumeLevel').textContent = '0%';
        }

        // --- Init ---
        window.openModal = () => document.getElementById('keyModal').style.display = 'flex';
        
        window.saveKey = () => {
            const key = document.getElementById('apiKey').value.trim();
            if(key) {
                localStorage.setItem('gemini_mobile_key_v5', key);
                initAI(key);
                document.getElementById('keyModal').style.display = 'none';
            }
        };

        const savedKey = localStorage.getItem('gemini_mobile_key_v5');
        if(savedKey) {
            document.getElementById('apiKey').value = savedKey;
            initAI(savedKey);
        } else {
            openModal();
        }

        function initAI(key) {
            try {
                genAI = new GoogleGenerativeAI(key);
                model = genAI.getGenerativeModel({ 
                    model: "gemini-2.5-flash",
                    systemInstruction: "ä½ æ˜¯ä¸€å€‹å°ˆæ¥­å£è­¯å“¡ã€‚è¦å‰‡ï¼š1. å°‡è¼¸å…¥ç¿»è­¯æˆç›®æ¨™èªè¨€ã€‚2. åªè¼¸å‡ºç¿»è­¯çµæœï¼Œä¸è¦æœ‰ä»»ä½•è§£é‡‹ã€‚3. é¢¨æ ¼è‡ªç„¶å£èªã€‚"
                });
                updateStatus("Ready");
            } catch(e) { 
                updateStatus("Key Error", "#ff453a");
                openModal();
            }
        }

        function updateStatus(text, color = "#8e8e93") {
            const el = document.getElementById('statusText');
            el.innerText = text;
            el.style.color = color;
        }

        // --- åˆ‡æ›èªè¨€ ---
        window.switchLang = (lang) => {
            targetLangMode = lang;
            document.querySelectorAll('.lang-option').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.lang-option[data-lang="${lang}"]`).classList.add('active');
            
            const btnOther = document.getElementById('btnOther');
            const btnText = document.getElementById('btnOtherText');
            
            btnOther.classList.remove('jp-mode', 'en-mode');
            
            if (lang === 'ja') {
                btnOther.classList.add('jp-mode');
                btnText.innerText = "JP";
                updateStatus("æ—¥æ–‡æ¨¡å¼");
            } else {
                btnOther.classList.add('en-mode');
                btnText.innerText = "EN";
                updateStatus("è‹±æ–‡æ¨¡å¼");
            }
        };

        // --- Beep ---
        function playBeep() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.type = 'sine';
            osc.frequency.setValueAtTime(880, audioCtx.currentTime); 
            gain.gain.setValueAtTime(0.05, audioCtx.currentTime); 
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1); 
        }

        // --- Voice Logic ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

        const btnTW = document.getElementById('btnTW');
        const btnOther = document.getElementById('btnOther');
        const btnRow = document.querySelector('.btn-row');
        const volumeMeterEl = document.getElementById('volumeMeter');
        const textPanel = document.getElementById('textPanel');
        const textInput = document.getElementById('textInput');
        const textTarget = document.getElementById('textTarget');
        const screen = document.getElementById('screen');
        const welcomeEl = document.querySelector('.welcome-text');
        const imagePanel = document.getElementById('imagePanel');
        const imageTarget = document.getElementById('imageTarget');
        const imageFileInput = document.getElementById('imageFileInput');
        const imageCaptureInput = document.getElementById('imageCaptureInput');

        window.switchMode = (mode) => {
            if (currentMode === mode) return;
            currentMode = mode;

            document.querySelectorAll('.mode-option').forEach(el => {
                el.classList.toggle('active', el.dataset.mode === mode);
            });

            if (mode === 'voice') {
                textPanel.classList.remove('active');
                imagePanel.classList.remove('active');
                btnRow.classList.remove('hidden');
                volumeMeterEl.classList.remove('hidden');
                updateStatus("Ready");
            } else if (mode === 'text') {
                if (isRecording && recognition) recognition.stop();
                stopVolumeMeter();
                btnRow.classList.add('hidden');
                volumeMeterEl.classList.add('hidden');
                textPanel.classList.add('active');
                updateStatus("æ–‡å­—ç¿»è­¯æ¨¡å¼");
                imagePanel.classList.remove('active');
            } else {
                if (isRecording && recognition) recognition.stop();
                stopVolumeMeter();
                btnRow.classList.add('hidden');
                volumeMeterEl.classList.add('hidden');
                textPanel.classList.remove('active');
                imagePanel.classList.add('active');
                updateStatus("åœ–ç‰‡ç¿»è­¯æ¨¡å¼");
            }
        };

        window.handleTextTranslate = async () => {
            const text = textInput.value.trim();
            if (!text) {
                updateStatus("è«‹å…ˆè¼¸å…¥å…§å®¹", "#ffcc00");
                return;
            }
            if (!model) {
                openModal();
                return;
            }

            const target = textTarget.value;
            let langName = 'Traditional Chinese';
            let speakCode = 'zh-TW';
            if (target === 'ja') { langName = 'Japanese'; speakCode = 'ja-JP'; }
            else if (target === 'en') { langName = 'English'; speakCode = 'en-US'; }

            updateStatus("ç¿»è­¯ä¸­...", "#ffcc00");

            const bubbleInfo = appendTextBubble(text, "ç¿»è­¯ä¸­...", speakCode);
            if (!bubbleInfo) return;

            try {
                const stream = await model.generateContentStream(`Translate to ${langName}: "${text}"`);
                let translated = '';
                for await (const chunk of stream.stream) {
                    translated += chunk.text();
                    bubbleInfo.transEl.textContent = translated || '...';
                    screen.scrollTop = screen.scrollHeight;
                }
                translated = (translated || '').trim();
                if (translated) {
                    bubbleInfo.transEl.textContent = translated;
                    bubbleInfo.bubble.onclick = () => {
                        speak(translated, speakCode);
                        bubbleInfo.bubble.style.opacity = '0.6';
                        setTimeout(() => bubbleInfo.bubble.style.opacity = '1', 120);
                    };
                    updateStatus("æ–‡å­—ç¿»è­¯å®Œæˆ", "#8e8e93");
                } else {
                    bubbleInfo.transEl.textContent = 'ç„¡æ³•å–å¾—çµæœ';
                    updateStatus("ç„¡æ³•å–å¾—çµæœ", "#ff3b30");
                }
            } catch (e) {
                console.error('Text translate error:', e);
                bubbleInfo.transEl.textContent = 'ç¿»è­¯å¤±æ•—';
                updateStatus("ç¿»è­¯å¤±æ•—", "#ff3b30");
            }
        };

        window.clearTextInput = () => {
            textInput.value = '';
            updateStatus("æ–‡å­—ç¿»è­¯æ¨¡å¼");
        };

        window.triggerImageUpload = () => imageFileInput.click();
        window.triggerImageCapture = () => imageCaptureInput.click();

        imageFileInput.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (file) handleImageTranslate(file);
            imageFileInput.value = '';
        });
        imageCaptureInput.addEventListener('change', (e) => {
            const file = e.target.files && e.target.files[0];
            if (file) handleImageTranslate(file);
            imageCaptureInput.value = '';
        });

        async function handleImageTranslate(file) {
            if (!model) {
                openModal();
                return;
            }
            const target = imageTarget.value;
            let langName = 'Traditional Chinese';
            let speakCode = 'zh-TW';
            if (target === 'ja') { langName = 'Japanese'; speakCode = 'ja-JP'; }
            else if (target === 'en') { langName = 'English'; speakCode = 'en-US'; }

            const objectUrl = URL.createObjectURL(file);
            const pending = appendImageBubble(objectUrl, 'ç¿»è­¯ä¸­...', speakCode, true);
            updateStatus("åœ–ç‰‡ç¿»è­¯ä¸­...", "#ffcc00");

            const reader = new FileReader();
            reader.onload = async () => {
                try {
                    let dataUrl = reader.result;
                    let mimeType = file.type || 'image/jpeg';

                    // åªåœ¨æª”æ¡ˆè¼ƒå¤§æ™‚æ‰å£“ç¸®ï¼Œä»¥åŠ é€Ÿè™•ç†
                    if (file.size > 1.5 * 1024 * 1024) {
                        try {
                            const compressed = await compressDataUrl(dataUrl, 960, 0.7);
                            dataUrl = compressed.dataUrl;
                            mimeType = compressed.mimeType || mimeType;
                        } catch (ce) {
                            console.warn('compress fallback', ce);
                        }
                    }

                    const base64 = dataUrl.split(',')[1];
                    const prompt = `You are an OCR translator. Extract all text and translate to ${langName}. Preserve the original layout order: process by top-to-bottom, then left-to-right. Keep line breaks exactly; separate distinct blocks with a blank line. Output only the translated lines (with blank lines between blocks), no numbering, no extra words.`;
                    const res = await model.generateContent([
                        { text: prompt },
                        { inlineData: { data: base64, mimeType } }
                    ]);
                    const translated = (res.response.text() || '').trim();

                    if (translated) {
                        pending.transEl.textContent = translated;
                        pending.transEl.style.display = 'block';
                        pending.bubble.onclick = null;
                        pending.imgEl.onclick = null;
                        updateStatus("åœ–ç‰‡ç¿»è­¯å®Œæˆ", "#8e8e93");
                    } else {
                        pending.transEl.textContent = 'ç„¡æ³•å–å¾—çµæœ';
                        updateStatus("ç„¡æ³•å–å¾—çµæœ", "#ff3b30");
                    }
                } catch (err) {
                    console.error('Image translate error:', err);
                    pending.transEl.textContent = 'ç¿»è­¯å¤±æ•—';
                    updateStatus("ç¿»è­¯å¤±æ•—", "#ff3b30");
                } finally {
                    URL.revokeObjectURL(objectUrl);
                }
            };
            reader.onerror = () => {
                pending.transEl.textContent = 'è®€å–åœ–ç‰‡å¤±æ•—';
                updateStatus("è®€å–åœ–ç‰‡å¤±æ•—", "#ff3b30");
                URL.revokeObjectURL(objectUrl);
            };
            reader.readAsDataURL(file);
        }

        async function drawTranslatedOnImage(dataUrl, translatedText) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    const padding = Math.max(12, img.width * 0.02);
                    const fontSize = Math.max(18, Math.round(img.width * 0.024));
                    const lineHeight = fontSize * 1.32;
                    const blockGap = lineHeight * 0.6;
                    ctx.font = `${fontSize}px "SF Pro Text", Arial, sans-serif`;
                    ctx.textBaseline = 'top';
                    ctx.textAlign = 'left';

                    // ä»¥ç©ºè¡Œåˆ†å¡Šï¼Œç´„ç•¥ä¿æŒç”±ä¸Šè€Œä¸‹çš„å€æ®µä½ç½®
                    const blocks = translatedText
                        .split(/\n\s*\n/)
                        .map(b => b.split('\n').map(l => l.trim()).filter(Boolean))
                        .filter(b => b.length);

                    const maxBlockWidth = canvas.width * 0.85;
                    const maxTextWidth = maxBlockWidth - padding * 2;

                    // é å…ˆè¨ˆç®—æ¯å€‹å€å¡Šé«˜åº¦èˆ‡å¯¬åº¦
                    const blockInfo = blocks.map(lines => {
                        const wrapped = wrapBlock(ctx, lines, maxTextWidth);
                        const maxLineWidth = wrapped.reduce((m, l) => Math.max(m, ctx.measureText(l).width), 0);
                        const boxWidth = Math.min(maxBlockWidth, maxLineWidth + padding * 2);
                        const boxHeight = wrapped.length * lineHeight + padding * 0.8;
                        return { wrapped, boxWidth, boxHeight };
                    });

                    const areaHeight = canvas.height - padding * 2;
                    const sumHeights = blockInfo.reduce((s, b) => s + b.boxHeight, 0);
                    let gap = blockGap;
                    if (blockInfo.length > 1) {
                        const ideal = (areaHeight - sumHeights) / (blockInfo.length - 1);
                        gap = Math.max(lineHeight * 0.4, Math.min(blockGap, ideal));
                    }
                    const totalHeight = sumHeights + gap * Math.max(0, blockInfo.length - 1);
                    let startY = padding + Math.max(0, (areaHeight - totalHeight) / 2);

                    blockInfo.forEach((info) => {
                        const boxX = (canvas.width - info.boxWidth) / 2;
                        const boxY = Math.min(startY, canvas.height - info.boxHeight - padding);

                        ctx.fillStyle = 'rgba(0,0,0,0.55)';
                        ctx.roundRect(boxX, boxY, info.boxWidth, info.boxHeight, 10);
                        ctx.fill();

                        ctx.fillStyle = '#fff';
                        let ty = boxY + padding * 0.4;
                        info.wrapped.forEach(line => {
                            ctx.fillText(line, boxX + padding * 0.7, ty);
                            ty += lineHeight;
                        });

                        startY = boxY + info.boxHeight + gap;
                    });

                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = reject;
                img.src = dataUrl;
            });
        }

        function wrapBlock(ctx, lines, maxWidth) {
            const out = [];
            lines.forEach(line => {
                if (!line) return;
                const words = line.split(' ');
                let current = '';
                words.forEach(word => {
                    const test = current ? `${current} ${word}` : word;
                    if (ctx.measureText(test).width > maxWidth && current) {
                        out.push(current);
                        current = word;
                    } else {
                        current = test;
                    }
                });
                if (current) out.push(current);
            });
            return out;
        }

        function compressDataUrl(dataUrl, maxSize = 1280, quality = 0.82) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    let { width, height } = img;
                    if (width <= maxSize && height <= maxSize) {
                        // ä¸éœ€ç¸®æ”¾
                        return resolve({ dataUrl, mimeType: 'image/jpeg' });
                    }
                    if (width > height && width > maxSize) {
                        height = Math.round(height * (maxSize / width));
                        width = maxSize;
                    } else if (height >= width && height > maxSize) {
                        width = Math.round(width * (maxSize / height));
                        height = maxSize;
                    }
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    const mime = 'image/jpeg';
                    const compressed = canvas.toDataURL(mime, quality);
                    resolve({ dataUrl: compressed, mimeType: mime });
                };
                img.onerror = reject;
                img.src = dataUrl;
            });
        }

        function appendTextBubble(originalText, translatedText, speakCode) {
            if (welcomeEl) welcomeEl.style.display = 'none';

            const bubble = document.createElement('div');
            bubble.className = 'msg msg-me';

            const originalEl = document.createElement('span');
            originalEl.className = 'original-text';
            originalEl.textContent = originalText;

            const transEl = document.createElement('div');
            transEl.className = 'translation';
            transEl.textContent = translatedText;

            const icon = document.createElement('span');
            icon.style.fontSize = '16px';
            icon.style.marginLeft = '5px';
            icon.textContent = 'ğŸ”Š';
            transEl.appendChild(icon);

            bubble.appendChild(originalEl);
            bubble.appendChild(transEl);

            bubble.onclick = () => {
                speak(translatedText, speakCode);
                bubble.style.opacity = '0.6';
                setTimeout(() => bubble.style.opacity = '1', 120);
            };

            screen.appendChild(bubble);
            requestAnimationFrame(() => screen.scrollTop = screen.scrollHeight);
            return { bubble, transEl };
        }

        function appendImageBubble(imgSrc, translatedText, speakCode, isPending = false) {
            if (welcomeEl) welcomeEl.style.display = 'none';

            const bubble = document.createElement('div');
            bubble.className = 'msg msg-me clickable';

            const img = document.createElement('img');
            img.className = 'img-preview';
            img.src = imgSrc;
            img.style.cursor = 'pointer';

            const transEl = document.createElement('div');
            transEl.className = 'translation';
            transEl.textContent = translatedText;

            bubble.appendChild(img);
            bubble.appendChild(transEl);

            screen.appendChild(bubble);
            requestAnimationFrame(() => screen.scrollTop = screen.scrollHeight);
            return { bubble, transEl, imgEl: img };
        }

        btnTW.onclick = (e) => handleBtnClick(e, btnTW, 'tw');
        btnOther.onclick = (e) => handleBtnClick(e, btnOther, 'other');

        function handleBtnClick(e, btn, role) {
            e.preventDefault();
            if(btnLock) return;

            window.speechSynthesis.cancel(); 
            const empty = new SpeechSynthesisUtterance('');
            window.speechSynthesis.speak(empty);

            if (isRecording) {
                if(recognition) recognition.stop();
                return;
            }

            let langCode;
            if (role === 'tw') {
                langCode = 'cmn-Hant-TW'; 
            } else {
                langCode = targetLangMode === 'ja' ? 'ja-JP' : 'en-US';
            }

            startRecording(btn, langCode, role);
        }

        function startRecording(btn, lang, role) {
            if(!SpeechRecognition) return;
            if(recognition) { try { recognition.abort(); } catch(e){} }
            
            playBeep();
            startVolumeMeter(); // é–‹å•ŸéŸ³é‡ç›£æ¸¬
            btnLock = true;
            setTimeout(() => btnLock = false, 300);

            recognition = new SpeechRecognition();
            
            recognition.lang = lang; // ä½¿ç”¨å®Œæ•´èªè¨€ä»£ç¢¼ (ja-JP, en-US, cmn-Hant-TW)
            recognition.interimResults = true; // æ‰€æœ‰èªè¨€éƒ½å•Ÿç”¨é€å­—é¡¯ç¤º
            recognition.maxAlternatives = 3; // å¢åŠ å‚™é¸çµæœï¼Œæé«˜æº–ç¢ºåº¦
            recognition.continuous = true; // æŒçºŒè½å–ï¼Œç›´åˆ°ç”¨æˆ¶æ‰‹å‹•åœæ­¢ 

            // Create Bubble
            let tempMsgDiv = document.createElement('div');
            tempMsgDiv.className = `msg ${role === 'tw' ? 'msg-me' : 'msg-other'}`;
            tempMsgDiv.innerHTML = `<span class="original-text" style="opacity:0.6;">æ­£åœ¨è†è½...</span>`; 
            
            const screen = document.getElementById('screen');
            screen.appendChild(tempMsgDiv);
            requestAnimationFrame(() => screen.scrollTop = screen.scrollHeight);

            const welcome = document.querySelector('.welcome-text');
            if(welcome) welcome.style.display = 'none';

            recognition.onstart = () => {
                isRecording = true;
                currentBtn = btn;
                btn.classList.add('recording');
                
                let label = "";
                if (lang === 'ja-JP') label = "Listening (JP)...";
                else if (lang === 'en-US') label = "Listening (EN)...";
                else label = "Listening (TW)...";
                updateStatus(label, "#007aff");
            };

            // å³æ™‚ç¿»è­¯ç›¸é—œè®Šæ•¸
            let transEl = null;
            let lastTranslatedText = '';
            let translateDebounceTimer = null;
            let isFinalized = false;
            let speakLangCode = '';
            let lastTranslatedResult = ''; // ä¿å­˜æœ€å¾Œç¿»è­¯çµæœ
            let accumulatedText = ''; // ç´¯ç©æ‰€æœ‰å·²ç¢ºèªçš„æ–‡å­—
            
            // é å…ˆå»ºç«‹ç¿»è­¯å€å¡Š
            function ensureTranslationElement() {
                if (!transEl) {
                    const transDiv = document.createElement('div');
                    transDiv.className = 'translation typing';
                    tempMsgDiv.appendChild(transDiv);
                    transEl = transDiv;
                }
                return transEl;
            }
            
            // å®Œæˆä¸¦åœæ­¢æ¸¸æ¨™
            function finishTranslation() {
                if (isFinalized) return;
                isFinalized = true;
                
                const el = ensureTranslationElement();
                el.classList.remove('typing');
                
                const finalText = lastTranslatedResult || el.innerText;
                if (finalText) {
                    el.innerHTML = `${finalText} <span style="font-size:16px; margin-left:5px;">ğŸ”Š</span>`;
                    updateStatus("Done");
                    speak(finalText, speakLangCode);
                    
                    tempMsgDiv.onclick = () => {
                        speak(finalText, speakLangCode);
                        tempMsgDiv.style.opacity = '0.6';
                        setTimeout(() => tempMsgDiv.style.opacity = '1', 100);
                    };
                } else {
                    el.classList.remove('typing');
                    updateStatus("Ready");
                }
            }
            
            // å³æ™‚ç¿»è­¯å‡½æ•¸
            async function translateRealtime(text, isFinal = false) {
                if (!text.trim()) return;
                if (isFinalized) return; // å·²å®Œæˆå°±ä¸å†ç¿»è­¯
                
                // ç›¸åŒæ–‡å­—ä¸”ä¸æ˜¯æœ€çµ‚ç‰ˆæœ¬ï¼Œè·³é
                if (text === lastTranslatedText && !isFinal) return;
                lastTranslatedText = text;
                
                // è¨­å®šèªè¨€
                if (role === 'tw') {
                    if (targetLangMode === 'ja') { speakLangCode = 'ja-JP'; } 
                    else { speakLangCode = 'en-US'; }
                } else {
                    speakLangCode = 'zh-TW';
                }
                
                let targetLangName;
                if (role === 'tw') {
                    targetLangName = targetLangMode === 'ja' ? 'Japanese' : 'English';
                } else {
                    targetLangName = 'Traditional Chinese';
                }
                
                try {
                    if (!model) return;
                    updateStatus("å³æ™‚ç¿»è­¯ä¸­...", "#ffcc00");
                    
                    const el = ensureTranslationElement();
                    const result = await model.generateContentStream(`Translate to ${targetLangName}: "${text}"`);
                    
                    let translatedText = '';
                    for await (const chunk of result.stream) {
                        if (isFinalized) break; // å¦‚æœå·²å®Œæˆå°±åœæ­¢
                        translatedText += chunk.text();
                        el.innerText = translatedText;
                        screen.scrollTop = screen.scrollHeight;
                    }
                    
                    lastTranslatedResult = translatedText;
                    
                    // å¦‚æœæ˜¯æœ€çµ‚çµæœï¼Œå®Œæˆç¿»è­¯
                    if (isFinal) {
                        finishTranslation();
                    }
                } catch(e) {
                    if (e.name !== 'AbortError') {
                        console.error('Translation error:', e);
                    }
                }
            }

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';
                
                // å¾æ‰€æœ‰çµæœä¸­æ”¶é›†æ–‡å­—
                for (let i = 0; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                
                // å®Œæ•´çš„ç•¶å‰æ–‡å­— = å·²ç¢ºèª + æš«æ™‚
                const fullText = finalTranscript + interimTranscript;
                
                // æ›´æ–°é¡¯ç¤ºçš„åŸæ–‡
                const el = ensureTranslationElement();
                
                // æ‰¾åˆ°æˆ–å‰µå»ºåŸæ–‡é¡¯ç¤ºå€
                let originalTextEl = tempMsgDiv.querySelector('.original-text');
                if (!originalTextEl) {
                    originalTextEl = document.createElement('span');
                    originalTextEl.className = 'original-text';
                    tempMsgDiv.insertBefore(originalTextEl, el);
                }
                
                // é¡¯ç¤ºå®Œæ•´æ–‡å­—ï¼Œæš«æ™‚éƒ¨åˆ†ç”¨è¼ƒæ·¡é¡è‰²
                if (interimTranscript) {
                    originalTextEl.innerHTML = `${finalTranscript}<span style="opacity:0.6">${interimTranscript}</span>`;
                } else {
                    originalTextEl.textContent = finalTranscript;
                }
                
                // ä¿å­˜ç´¯ç©æ–‡å­—
                accumulatedText = fullText;
                
                screen.scrollTop = screen.scrollHeight;
                
                // å³æ™‚ç¿»è­¯ (ä½¿ç”¨ debounce é¿å…éæ–¼é »ç¹)
                clearTimeout(translateDebounceTimer);
                
                    if (fullText && fullText.length > 3) {
                        // ç¸®çŸ­ debounceï¼ŒåŠ å¿«ç¿»è­¯è§¸ç™¼
                        translateDebounceTimer = setTimeout(() => {
                            translateRealtime(fullText, false);
                        }, 300);
                    }
            };

            recognition.onend = () => { 
                stopRecording(); 
                clearTimeout(translateDebounceTimer);
                
                // ç”¨æˆ¶åœæ­¢éŒ„éŸ³ï¼ŒåŸ·è¡Œæœ€çµ‚ç¿»è­¯
                if (accumulatedText && accumulatedText.trim()) {
                    // æ›´æ–°åŸæ–‡é¡¯ç¤ºç‚ºæœ€çµ‚ç‰ˆæœ¬
                    const originalTextEl = tempMsgDiv.querySelector('.original-text');
                    if (originalTextEl) {
                        originalTextEl.textContent = accumulatedText;
                    }
                    // åŸ·è¡Œæœ€çµ‚ç¿»è­¯ä¸¦æ’­æ”¾
                    translateRealtime(accumulatedText, true);
                } else if (transEl) {
                    finishTranslation();
                }
            };
            recognition.onerror = (e) => {
                stopRecording();
                clearTimeout(translateDebounceTimer);
                if(e.error === 'aborted' || e.error === 'no-speech') {
                    if(!accumulatedText) tempMsgDiv.remove();
                    return;
                }
                updateStatus("è«‹å†è©¦ä¸€æ¬¡", "#ff3b30");
                if(!accumulatedText) tempMsgDiv.remove();
            };
            try { recognition.start(); } catch(e) { btnLock = false; }
        }

        function stopRecording() {
            isRecording = false;
            if(currentBtn) currentBtn.classList.remove('recording');
            currentBtn = null;
            stopVolumeMeter(); // é—œé–‰éŸ³é‡ç›£æ¸¬
            updateStatus("Ready");
        }

        // --- å³æ™‚ç¿»è­¯æ¨¡å¼ (å·²æ•´åˆåˆ° startRecording ä¸­) ---

        let speaking = false;
        function speak(text, lang) {
            // è‹¥æ­£åœ¨æœ—è®€ï¼Œå†æ¬¡é»æ“Šç›´æ¥åœæ­¢
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
                speaking = false;
                updateStatus("æœ—è®€å·²åœæ­¢", "#8e8e93");
                return;
            }
            const u = new SpeechSynthesisUtterance(text);
            u.lang = lang;
            speaking = true;
            updateStatus("æœ—è®€ä¸­...", "#ffcc00");
            u.onend = () => {
                speaking = false;
                updateStatus("Ready");
            };
            u.onerror = () => {
                speaking = false;
                updateStatus("æœ—è®€å¤±æ•—", "#ff3b30");
            };
            window.speechSynthesis.speak(u);
        }
    </script>
</body>
</html>